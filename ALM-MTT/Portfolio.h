#pragma once

#include <memory>
#include <vector>
#include <atomic>
#include <functional>
#include "TaskExecutor.h"
#include "Date.h"
#include "Curve.h"
#include "Asset.h"

namespace ALM {

    /**
     * @brief Represents a collection of financial assets and supports concurrent valuation.
     *
     * The portfolio provides methods for calculating market value and cash flows using a yield curve
     * and a task executor for parallel evaluation.
     */
    class Portfolio {
    public:
        Portfolio() = default;

        /**
         * @brief Constructs a portfolio from a given list of assets.
         */
        Portfolio(std::vector<Asset> assets)
            : assets_(std::move(assets)) {
        }

        /**
         * @brief Add a new asset to the portfolio.
         */
        void addAsset(Asset asset) {
            assets_.push_back(std::move(asset));
        }

        /**
         * @brief Computes the total market value of the portfolio as of a given reference date.
         *
         * @param curve Discount curve used to value each asset.
         * @param ref The reference date.
         * @param executor Task executor for concurrent evaluation.
         * @return Present value of all assets in the portfolio.
         */
        double marketValue(const std::shared_ptr<const Curve>& curve, const Date& ref, const std::shared_ptr<TaskExecutor>& executor) const {
            std::atomic<double> total = 0.0;
            std::vector<std::function<void()>> tasks;

            for (const auto& asset : assets_) {
                tasks.emplace_back([&asset, &curve, &ref, &total]() {
                    total += asset.marketValue(curve, ref);
                    });
            }

            executor->submitAndWait(tasks);
            return total;
        }

        /**
         * @brief Computes the total cash flow from all assets over a date range.
         *
         * @param from Start date (exclusive).
         * @param to End date (inclusive).
         * @param executor Task executor for concurrent evaluation.
         * @return Total cash flow generated by all assets in the range.
         */
        double cashFlow(const Date& from, const Date& to, const std::shared_ptr<TaskExecutor>& executor) const {
            std::atomic<double> total = 0.0;
            std::vector<std::function<void()>> tasks;

            for (const auto& asset : assets_) {
                tasks.emplace_back([&asset, &from, &to, &total]() {
                    total += asset.cashFlow(from, to);
                    });
            }

            executor->submitAndWait(tasks);
            return total;
        }

        /**
         * @brief Access to the asset vector for iteration or mutation.
         */
        std::vector<Asset>& assets() {
            return assets_;
        }

    private:
        std::vector<Asset> assets_;
    };

}
